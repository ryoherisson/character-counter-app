class MeshAnimation {
    constructor() {
        this.canvas = document.getElementById('meshCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.animationId = null;
        
        this.gridSize = window.innerWidth < 768 ? 50 : 30;
        this.nodes = [];
        this.time = 0;
        this.animationSpeed = window.innerWidth < 768 ? 0.01 : 0.02;
        
        this.init();
        this.setupEventListeners();
        this.animate();
    }
    
    init() {
        this.resizeCanvas();
        this.createNodes();
    }
    
    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    createNodes() {
        this.nodes = [];
        const cols = Math.ceil(this.canvas.width / this.gridSize) + 1;
        const rows = Math.ceil(this.canvas.height / this.gridSize) + 1;
        
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                this.nodes.push({
                    x: i * this.gridSize,
                    y: j * this.gridSize,
                    originalX: i * this.gridSize,
                    originalY: j * this.gridSize,
                    offsetX: Math.random() * 20 - 10,
                    offsetY: Math.random() * 20 - 10
                });
            }
        }
    }
    
    updateNodes() {
        this.time += this.animationSpeed;
        
        this.nodes.forEach((node, index) => {
            const waveX = Math.sin(this.time + index * 0.01) * 15;
            const waveY = Math.cos(this.time + index * 0.015) * 10;
            
            node.x = node.originalX + waveX + node.offsetX;
            node.y = node.originalY + waveY + node.offsetY;
        });
    }
    
    drawMesh() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.strokeStyle = '#333333';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.6;
        
        const cols = Math.ceil(this.canvas.width / this.gridSize) + 1;
        const rows = Math.ceil(this.canvas.height / this.gridSize) + 1;
        
        for (let j = 0; j < rows; j++) {
            this.ctx.beginPath();
            for (let i = 0; i < cols; i++) {
                const nodeIndex = i * rows + j;
                if (nodeIndex < this.nodes.length) {
                    const node = this.nodes[nodeIndex];
                    if (i === 0) {
                        this.ctx.moveTo(node.x, node.y);
                    } else {
                        this.ctx.lineTo(node.x, node.y);
                    }
                }
            }
            this.ctx.stroke();
        }
        
        for (let i = 0; i < cols; i++) {
            this.ctx.beginPath();
            for (let j = 0; j < rows; j++) {
                const nodeIndex = i * rows + j;
                if (nodeIndex < this.nodes.length) {
                    const node = this.nodes[nodeIndex];
                    if (j === 0) {
                        this.ctx.moveTo(node.x, node.y);
                    } else {
                        this.ctx.lineTo(node.x, node.y);
                    }
                }
            }
            this.ctx.stroke();
        }
        
        this.ctx.fillStyle = '#666666';
        this.nodes.forEach(node => {
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, 1, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    animate() {
        this.updateNodes();
        this.drawMesh();
        this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    setupEventListeners() {
        window.addEventListener('resize', this.debounce(() => {
            this.gridSize = window.innerWidth < 768 ? 50 : 30;
            this.animationSpeed = window.innerWidth < 768 ? 0.01 : 0.02;
            this.resizeCanvas();
            this.createNodes();
        }, 250));
    }
    
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new MeshAnimation();
});