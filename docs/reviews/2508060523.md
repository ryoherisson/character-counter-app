# 文字数カウンターアプリ：黒背景＋動くメッシュ追加手順

## 概要
既存の文字数カウンターアプリの背景を黒色に変更し、うねうね動くメッシュ状の構造体を追加する手順。

## 1. CSSの背景変更

### style.cssの変更点
```css
/* 既存のbody要素のbackgroundを変更 */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #000000; /* 黒背景に変更 */
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    overflow: hidden; /* メッシュアニメーション用 */
    position: relative;
}

/* メッシュアニメーション用のキャンバス要素 */
#meshCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.3;
}

/* コンテナの透明度調整 */
.container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 15px 35px rgba(255, 255, 255, 0.1);
    width: 100%;
    max-width: 600px;
    z-index: 1;
    position: relative;
}
```

## 2. HTMLにキャンバス要素追加

### index.htmlの変更
```html
<body>
    <!-- メッシュアニメーション用キャンバス -->
    <canvas id="meshCanvas"></canvas>
    
    <div class="container">
        <h1>文字数カウンター</h1>
        <!-- 既存のコンテンツはそのまま -->
        <textarea id="textInput" placeholder="文字を入力してください..."></textarea>
        <div class="stats">
            <!-- 既存の統計表示要素 -->
        </div>
        <button id="clearBtn">クリア</button>
    </div>
    
    <script src="mesh-animation.js"></script>
    <script src="script.js"></script>
</body>
```

## 3. メッシュアニメーションJavaScript作成

### mesh-animation.jsファイルの作成
```javascript
class MeshAnimation {
    constructor() {
        this.canvas = document.getElementById('meshCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.animationId = null;
        
        // メッシュの設定
        this.gridSize = 30;
        this.nodes = [];
        this.time = 0;
        
        this.init();
        this.setupEventListeners();
        this.animate();
    }
    
    init() {
        this.resizeCanvas();
        this.createNodes();
    }
    
    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    createNodes() {
        this.nodes = [];
        const cols = Math.ceil(this.canvas.width / this.gridSize) + 1;
        const rows = Math.ceil(this.canvas.height / this.gridSize) + 1;
        
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                this.nodes.push({
                    x: i * this.gridSize,
                    y: j * this.gridSize,
                    originalX: i * this.gridSize,
                    originalY: j * this.gridSize,
                    offsetX: Math.random() * 20 - 10,
                    offsetY: Math.random() * 20 - 10
                });
            }
        }
    }
    
    updateNodes() {
        this.time += 0.02;
        
        this.nodes.forEach((node, index) => {
            const waveX = Math.sin(this.time + index * 0.01) * 15;
            const waveY = Math.cos(this.time + index * 0.015) * 10;
            
            node.x = node.originalX + waveX + node.offsetX;
            node.y = node.originalY + waveY + node.offsetY;
        });
    }
    
    drawMesh() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.strokeStyle = '#333333';
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.6;
        
        const cols = Math.ceil(this.canvas.width / this.gridSize) + 1;
        const rows = Math.ceil(this.canvas.height / this.gridSize) + 1;
        
        // 水平線を描画
        for (let j = 0; j < rows; j++) {
            this.ctx.beginPath();
            for (let i = 0; i < cols; i++) {
                const nodeIndex = i * rows + j;
                if (nodeIndex < this.nodes.length) {
                    const node = this.nodes[nodeIndex];
                    if (i === 0) {
                        this.ctx.moveTo(node.x, node.y);
                    } else {
                        this.ctx.lineTo(node.x, node.y);
                    }
                }
            }
            this.ctx.stroke();
        }
        
        // 垂直線を描画
        for (let i = 0; i < cols; i++) {
            this.ctx.beginPath();
            for (let j = 0; j < rows; j++) {
                const nodeIndex = i * rows + j;
                if (nodeIndex < this.nodes.length) {
                    const node = this.nodes[nodeIndex];
                    if (j === 0) {
                        this.ctx.moveTo(node.x, node.y);
                    } else {
                        this.ctx.lineTo(node.x, node.y);
                    }
                }
            }
            this.ctx.stroke();
        }
        
        // ノードを描画
        this.ctx.fillStyle = '#666666';
        this.nodes.forEach(node => {
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, 1, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    animate() {
        this.updateNodes();
        this.drawMesh();
        this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    setupEventListeners() {
        window.addEventListener('resize', () => {
            this.resizeCanvas();
            this.createNodes();
        });
    }
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
}

// DOMContentLoaded後に初期化
document.addEventListener('DOMContentLoaded', () => {
    new MeshAnimation();
});
```

## 4. 代替案：CSS-onlyのメッシュアニメーション

### よりシンプルなCSS-onlyバージョン
```css
/* メッシュ背景のCSS実装 */
body::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 30px 30px;
    animation: meshMove 20s linear infinite;
    z-index: -1;
}

@keyframes meshMove {
    0% {
        transform: translate(0, 0);
    }
    25% {
        transform: translate(10px, 5px);
    }
    50% {
        transform: translate(-5px, 10px);
    }
    75% {
        transform: translate(8px, -3px);
    }
    100% {
        transform: translate(0, 0);
    }
}

/* 追加の波紋効果 */
body::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.05) 0%, transparent 50%);
    animation: ripple 15s ease-in-out infinite;
    z-index: -1;
}

@keyframes ripple {
    0%, 100% {
        transform: scale(1);
        opacity: 0.3;
    }
    50% {
        transform: scale(1.1);
        opacity: 0.1;
    }
}
```

## 5. 高度なメッシュアニメーション（Three.js使用）

### Three.jsを使った3Dメッシュ実装
```html
<!-- Three.jsライブラリの読み込み -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
```

```javascript
class ThreeMeshAnimation {
    constructor() {
        this.container = document.body;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ alpha: true });
        
        this.init();
        this.createMesh();
        this.animate();
    }
    
    init() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.domElement.style.position = 'absolute';
        this.renderer.domElement.style.top = '0';
        this.renderer.domElement.style.left = '0';
        this.renderer.domElement.style.zIndex = '-1';
        this.renderer.domElement.style.opacity = '0.3';
        this.container.appendChild(this.renderer.domElement);
        
        this.camera.position.z = 5;
    }
    
    createMesh() {
        const geometry = new THREE.PlaneGeometry(10, 10, 20, 20);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x333333, 
            wireframe: true 
        });
        
        this.mesh = new THREE.Mesh(geometry, material);
        this.scene.add(this.mesh);
        
        // 頂点の元の位置を保存
        this.originalPositions = geometry.attributes.position.array.slice();
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        const time = Date.now() * 0.001;
        const positions = this.mesh.geometry.attributes.position.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            const x = this.originalPositions[i];
            const y = this.originalPositions[i + 1];
            
            positions[i + 2] = Math.sin(x * 0.5 + time) * 0.3 + Math.cos(y * 0.5 + time) * 0.3;
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.rotation.x = time * 0.1;
        this.mesh.rotation.y = time * 0.1;
        
        this.renderer.render(this.scene, this.camera);
    }
}
```

## 6. 実装手順

### ステップ1: 基本的な黒背景とメッシュ
1. style.cssのbody背景を黒に変更
2. Canvas要素をHTMLに追加
3. mesh-animation.jsファイルを作成
4. script.jsの読み込み前にmesh-animation.jsを読み込み

### ステップ2: パフォーマンス最適化
```javascript
// レスポンシブ対応とパフォーマンス最適化
if (window.innerWidth < 768) {
    // モバイルでは簡単なアニメーションに切り替え
    this.gridSize = 50; // グリッドサイズを大きく
    this.animationSpeed = 0.01; // アニメーション速度を下げる
}
```

### ステップ3: ブラウザ互換性確認
- Canvas APIサポート確認
- requestAnimationFrameのフォールバック
- モバイル端末でのパフォーマンス調整

## 7. トラブルシューティング

### よくある問題と解決法

#### パフォーマンス問題
- グリッドサイズを調整（30px → 50px）
- アニメーション速度を下げる
- モバイルでは静的メッシュに切り替え

#### 描画の問題
- Canvas要素のz-indexを適切に設定
- overflow: hiddenでスクロールバーを非表示
- 透明度の調整でバランスを取る

#### レスポンシブ対応
```javascript
window.addEventListener('resize', debounce(() => {
    this.resizeCanvas();
    this.createNodes();
}, 250));

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
```

## まとめ

この手順に従うことで、文字数カウンターアプリに動的で視覚的に魅力的な黒背景とメッシュアニメーションを追加できます。実装の複雑さに応じて、CSS-only版からThree.js版まで選択できます。